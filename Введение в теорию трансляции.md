# Глава 1. Теория формальных языков
## § 1. Основные определения 

Первичное понятие - символ
Опр 1: Алфавит - конечное множество символов
Опр 2: Цепочка символов в алфавите $V$ - конечная последовательность символов алфавита
$\epsilon$ - пустая цепочка 
Опр 3: Длина цепочки - количество символов $\left| \alpha \right|$
	$\left| \epsilon \right|$ = 0
Опр 4. $\alpha^R$ - реверс цепочки $\alpha$ - символы в обратном порядке
Опр 5. Конкатенация цепочек альфа и бета - это цепочка $\alpha\beta$ (символы альфа, потом символы бета)
Опр 6. Степень цепочки альфа ($\alpha^n$) - конкатенация n цепочек альфа
________________________________________________________________________
Опр 7. Множество $V^*$ - множество всех цепочек в алфавите $V$, включая $\epsilon$
Опр 8. Множество V+ = V*\\{E}
Опр 9. Формальный язык L в алфавите V - это подмножество  V*. L(v)
	Замечания
	1) L - может быть конечным или бесконечным
	2) Цепочка в алфавите V может принадлежать или не принадлежать языку

## § 2. Механизм описания Формальных Языков
1)Механизм порождения - свод правил, которые описывают, как из некой аксиомы получить все цепочки, принадлежащие языку.
Формализм: Порождающая грамматика.
2)Механизм Распознавания - есть автомат. На вход поступают цепочки. 
Y - цепочки принадлижащии языку
N - цепочки непринадлижащии языку.
Автомат отвечает Y на все цепочки, принадлежащии языку и только на них.
Формализм: Конечный автомат, Магазинный автомат, Д - граф, Машина Тьюринга.

## § 3. Порождающая грамматика
Опр 1: Порождающая грамматика G - это 4 - ка объектов (T, N, P, S)
T - множество терминальных символов (алфавит порождемого языка)
N - множество нетерминальных символов символов.
T пересечение с N = пустое множество
P - множество правил вывода вида:
	альфа(левая часть) -> бета(правая часть)
альфа принадлежит V+; B принадлежит V*
альфа содержит хотя бы 1 нетерминал.
S - начальны символ грамматики (аксиома, с которой начинается порождение).
S принадлежит N

________________________________________________________________________
Пример: Т = {0, 1} N = {S(начальный символ грамматики), A}
P:
	S -> 0A1
	0A -> 00A1
	A -> E

Процесс порождения: 
S -> 0A1 (01, т. к. A -> E) -> 00A11 (0011) -> 000A111 (000111) -> ....
L(G) = {0^n1^n, n >= 1}
________________________________________________________________________

Опр 2: цепочка бета непосредственно выводима в грамматике G из цепочки альфа, если 
бета имеет структуру: W1 дельта W2
альфа имеет структуру: W1 гамма W2
и в грамматике G есть правило гамма -> дельта
дельта принадлежит(T объединение N)+;  гамма принадлежит(T объединение N)*
W1, W2 - контекст
	W1, W2 принадлежат (T объединение с N)*
Опр 3: цепочка бета выводма из цепочки альфа, если существует последовательность цепочек гамма1, гамма2, ... гаммаN таких что
альфа -> гамма1 -> гамма2 -> ... -> бета
Опр 4: Язык L, порождаемый грамматикой, это множество терминальных цепочек, порождаемых из S
Опр 5: Сентенциальная форма в грамматике G - это любая цепочка, выводимая из S
Опр 6: Грамматика G1 и G2 эквиваленты, если L(G1) = L(G2)

## § 4. Нотационная форма Бэкуса - Наура 
Нет стрелок
Ссылки на понятия: < >
| - или

\<while\>:: = while(\<выраж.\>)\<оператор\>

Основные отличия Формы Бэкуса - Наура и игрушечных грамматик

| Бэкус - Наур      | Игрушечная грамматика |
| ----------------- | --------------------- |
| ::=               | ->                    |
| Нетерминалы в < > | Нетерминалы A         |

Еще примеры:
<имя> ::= <буква>|<имя><буква>|<имя><цифра>

\<if\> ::= if(\<expression\>)\<оператор\>
\[else \<оператор\>\]

\[\] - служебный символ повторение 0 или 1 раз.
{} - Повторение 0 или более раз.
Замечание: это служебный символы для упрощения записи, но могут усложнять анализ $=>$ используем осмысленно 

<оператор> ::= \<if\>|\<while\>|\<switch\>|\<for\>|\<do while\>|\<блок\>...
<блок> ::= {{\<оператор\>}}

## § 5. Классификация грамматик и языков по Хомскому
Общая закономерность: чем выше тип, тем проще анализ.
Тип 0. Грамматики  общего вида. Все грамматики
### Тип 1. Неукорачивающие 
$\alpha$ -> $\beta$, причем $\left| \alpha \right| <= \left| \beta \right|$
Исключение $S$ -> $\epsilon$, если S не встречается в правой части правил вывода.
	Пример:
	$S$ -> $aSBC|abc$ 
	CB 
### Тип 2. Контекстно свободные (кс)
Каждое правило имеет вид: $A$ -> $\alpha$
$A$ принадлежит N; $\alpha$ принадлежит ($T$ пересечь $N$$)^*$
Пример:
$S$ -> $aSa|aSb|\epsilon$
Теорема: Для любой КС грамматики существует эквивалентная ей неукорачивающая КС грамматика.
Есть общий алгоритм
### Тип 3. Регулярные грамматики.

| Леволинейные                                                    | Праволинейные                                            |
| --------------------------------------------------------------- | -------------------------------------------------------- |
| 1)A -> $a\|\epsilon$   A принадлежит N ; $a$ принадлежит T      | 1) A->a\|E    A принадлежит N; a принадлежит T           |
| 2) A-> B$\alpha$    B, A принадлежат N; $\alpha$ принадлежит T* | 2) A->альфаB.   A, B принадлежат N; альфа принадлежит T* |
Теорема: Для любой регулярной грамматики можно посторить эквивалентную неукорачиваемую грамматику.
### Тип формального языка
Опр. Тип языка - наивысший тип грамматики, пораждаюзей данный язык
1. Для любого сколь угодно хорошего языка можно написать сколь угодно плохую грамматику
2. Задача: Существует ли грамматика более высокого типа, эквивалентная данной? -> Алгоритмически неразрешима 
Замечание: 
1. Я. П. - контекстно свободные
2. Исукусственный пример типа 0 строится, содержательный - пока что нет.
## § 6. Очистка КС - грамматики от спама.

2 вида спама.
1. Бесплодные (бесполезные символы) принадлежат N. Опр. Бесплодные нетерминалы - это нетерминалы, из которых вывести нетерминальную цепочку невозможно.
	Пример:
	S -> aSAB | bDAC | eEA
	A -> Ak | kA | Ec
	B -> BD | BA | DD
	C -> (Eps) | x
	D -> AD = ? bB
	E -> *

	Алгоритм поиска бесплодных символов
	Сторится каскад множеств
	N(i) = N(i-1) объединение с (Нетерминалы, из которых выводится цепочки, содержащие терминалы и элементы N(i-1))
	N(0) = пустое множество
	N(i) = N(i-1) -> завершаем. Бесплодные символы N \\ N(i).

	Алгоритм удаления бесплодных символов 
	1) Вычеркнуть все строки бесплодные символы
	2) Вычеркнуть все альтернативы, содержащие бесплодные символы.

2. Недостижимые символы принадлежит (N объединение T)
	Опр. Недостижимиые символы не выводятся 
	Алгоритм поиска недостижимых символов 
	V(i) = V(i-1) + {символы, содержащиеся в альтернативах элементов V(i-1)}
	V(0) = {S}
	завершаем V(i) = V(i-1)
	Недостижимые: (N объединение Е) \\ V(i)

	Замечание: при удаление бесплодных символов могут возникнуть недостижимые => бесплодные удаляются первыми

3. Устранение в КС грамматики правил Eps
	0) Строим множество X <= N. В X включаются нетерминалы, из которых выводится Eps. не обязательно непосредственно
	1) Вычеркнуть все Eps правила
	2) ввести новый начальный символ грамматики S'
		Если S принадлежит X
		S' -> S|Eps
		Если S не принадлежит X
		S' = S
	3) Рассматриваем все правила по структуре:
		B -> альфа1A1альфа2A2...AnAльфаn+1
		Ai принадлежит X, альфаi - не содержит символов из X
		правило заменяется на 2^n правил (есть Ai или нет Ai)
		Гадость: могут появится бесплодные символы => нужна очистка

# Глава 2. Устройство транслятора
## § 1. Этапы процесса трансляции

### Трансляторы: 1) Компиляторы 2) Интерпретаторы

### Этапы
1) лексический анализ
	Текст => лексемы
	лексема = минимальная значимая единица языка.
	Примеры: c1; 123; ++; +=; for; (; ); ,;
2) Синтаксический анализ
	In - последовательность лексем
	out - Y/N - соответстует ли грамматике языка
	(диагностика ошибок)
3) Симантический анализ (контроль контекстных условий)
	Пример a(int)/S(string) - ошибка
	int a = 0; double a; - ошибка
4) Генерация внутреннего представления 
5) Исполнение / ассемблер / exe 
## § 2. Регулярные языки. Алгоритм анализа.

| Леволинейная               | Праволинейная              |
| -------------------------- | -------------------------- |
| A -> $\alpha$              | A -> $\alpha$              |
| A -> B$\alpha$             | A -> $\alpha$B             |
| $\alpha$ принадлежит $T^*$ | $\alpha$ принадлежит $T^*$ |
| A, B принадлежат N         | A, B принадлежат N         |

### Опр. Автоматная регулярна грамматика:

| Леволинейная       | Праволинейная      |
| ------------------ | ------------------ |
| A -> a             | A -> a             |
| A -> Ba            | A -> aB            |
| A принадлежит T    | A принадлежит T    |
| A, B принадлежат N | A, B принадлежат N |
Автоматная грамматика неукорачивающая

### Опр. Конечный автомат - это 5 ка
{K, T, F, H, S}
K - конечное множество состояний 
T - алфавит распознаваемого языка
F - функция перехода
H - начальное состояние
S - множество заключающий состояний 

Леволинейная грамматика <-> Автомат
T <-> T
N <-> K
S <-> S
P <-> F

| A -> Ba | B ->(a) A |
| ------- | --------- |
| A -> a  | H ->(a) A |
H - дополнительное состояние без нетерминала 


Праволинейная грамматика <-> Автомат
T <-> T
N <-> K
S <-> H
P <-> F

| A -> aB | A ->(a) B |
| ------- | --------- |
| A -> a  | A ->(a) S |

Есть недотерминированный конечный автомат (нка)

Анализатор цепочек по Д. К. А.
2 переменных и 1 swicth
с - текущий символ.
K(H) - состояние (enum)

## § 3. Лексический анализ. 
1) Разбить тест программы на лексемы.
2) Убираем ' ' и enter.
3) Убрать комментарии 
________________________________________________________________________
Лексема: <тип, содержимое>
Пример типизации лексем
1 - служебное зареверзированное слово. (список в отдельном файле)
2 - идентификатор A(A|1)
3 - литерал 
	123;
3* - строковый литерал
	"abc"
4 - операция
	+; -; =; >; <=; ++; --; &; |;  \*=; +=; -=; /=; %=; %; &&; ||; /; !; !=; \==; 
5 - пунктуация 
	";" "{" "}"
6 - "."
7 - ","

### Этап 1 к сдаче.
Текст программы ->  ЛА -> Список лексем с типами 

### Пример.
int gcd(int a, int b) {
	int r;
	for  (; b != 0; r = a % b, a = b, b = r);
	return a;
}
лексемы:
int - 1, 2
gcd - 2
( - 8
int - 1, 2
a - 2
, - 7(5)
int - 1, 2
b - 2
) - 8
{ - 5
int - 1, 2
r - 2
; - 5
for - 1
( - 8
; - 5
b - 2
!= - 4
0 - 3
; - 5
r - 2
\= - 4
a - 2
% - 4
b - 2
, - 7(4)
a - 2
\= - 4
b - 2
a - 2
, - 7(4)
b - 2
\= - 4
b - 2
, - 7(4)
b - 2
= - 4
r - 2
) - 8
; - 5
return - 1
a - 2
; - 5
} - 5

Рекомендация. На этапе ЛА разделяем содержимое многозначных значков.
\+ bin и + uno
\*(умножение) и \*(разыменование)
&(битовое и) и &(ссылка)

ошибка - символ, который не входит в алфавит языка. - Реакция ЛА
1) error throw
2) num 13 - "иное" - ошибку даст синтаксический анализатор

### Для красивой диагностики ошибок.
Хочется сохранить N строки в исходном файле.
Лексема:
<тип; содержимое; номер строки>
### Требования эффективности лексического анализа.
1) Бор служебных зарезервированных слов
2) Считываем весь текст программы методом read в выделенную new динамическую память

## 4 §. Синтаксический анализ
### Структура программы 2 этап.
Вход: последовательность лексем
Знает: грамматику языка
Выход: Дифференцир диагностика ошибки или ОК
### Требуется. Анализ грамматик типа 2, ибо Я. П. имеет тип 2.
### Программа 2 Этапа.

#### starter 
+ инцилизирущий блок
1) read на весь текст программы
2) Формирование бора служебных зарезервированных слов

## § 5. Требования к языку программирования.
1) Переменные, присваивания.
2) выражения: арифметика, сравнения, логика(and or, not), операция ","
3) ветвления: if, switch(сложное ветвление)
4) циклы: while, for(;;), break, continue
5) типы: int, double(float), array, string, (дополнительные: bool, char)
6) Функции (перегрузка по желанию, простой вариант: нет приведений типов)

## § 6. Метод рекурсивного спуска.
Универсальные алгоритмы анализа КС языков(тип 2)
1) Алгоритм Кока - Янгреа - Касами O(n^3)
2) Алгоритм Эрли O(n^2)
3) Рекурсивный спуск: O(n) (Применим не к каждой грамматики)
Принципы Р. С.
1) Каждый нетерминал - это функция
2) Каждая альтернатива - разбор случаев
3) Если мы видим терминал в грамматик, то сравниваем с ним лексемы Y -  далее, N - error
4) Если видим нетерминал в правиле вывода вызываем фнукцию 

Пример:
S -> ABd
A -> a | cA
B -> bA
lex - глобальная переменная - очередная лексема (символ)
get_lex - функция, присваивающая lex новую лексему (вызов лексического анализа)
соглашение: При запуске функции считается. что lex уже прочитана
void S() {
	A();
	B();
	if (lex != 'd')
		trow lex;
	retrurn;
}
void A() {
	if (lex == 'a') {
		get_lex();
	} else if (lex == 'c') {
		get_lex();
		A();
	} else 
		trow lex;
	return;
}

void B() {
	if (lex == 'b') {
		get_lex();
		A();
	} else
		trow lex;
}

int main() {
	try {
		get_lex();
		S();
		if (lex != 'L') throw lex;
		cout << "OK!";
		return 0;
	}
	catch(lextype lex) {
		cout << "error in lex" << lex;
		return 1;
	}
}

## § 7. Применимость метода Рекурсивного спуска.
Достаточное условие, Рукурсивный спуск применим, если для каждого нетерминала справедливо одно из 2 условий:
1) Все альтернативы начинаются с различных терминалов
2) У нетерминала 1 альтернатива 
Замечание: Существует ли грамматика эквивалентная данной, к которой применим рукурсивный спуск - алгоритмичеси неразрешима
Вспомогательные понятия:
Опр 1: Множество first($\alpha$) - множество терминалов, с которых могут начинаться цепочки выводимые из $\alpha$
Опр 2: Множество fellow($\alpha$) - множество нетерминалов, с которых могут начинаться цепочки сразу за цепочками выводимыми из $\alpha$ 

Пример:
	S -> ABd
	A -> a | cA
	B -> bA
	
	First(A) = {a, c}
	Follow(A) = {b, d}
	First(B) = {b}
	Follow(B) = {d}
	First(S) = {a, c}
	Follow(S) = {}

### Критерий применимости рекусивного спуска
рекурсивный спуск применим к грамматике G <=>
<=> Для любой пары альтернатив X -> $\alpha$ | $\beta$ 
выполняются все 3 пункта:
1) first($\alpha$) пересечь first($\beta$) = пустое множество
2) Справедливо не более чем 1 из соотношений: $\alpha$ => Eps; $\beta$ => Eps
3) Если бета => Eps, то first(x) пересечь follow(x) = пустое множество
Пример.
S -> BDC
C -> Bd
D -> aB | d
B -> bB | Eps
first(B) = {b}
follow(B) = {a, d, b}
first(B) пересечь follow(B) != пустое множество => не применимо

### Преобразование грамматик 
1) Избавление от левой рекурсии 
	Было:
	A -> A$\alpha 1$   | A$\alpha 2$ | A$\alpha 3$ | ... | A $\alpha n$  | $\beta1$ | ... | $\beta k$ 
	Прямая рекурсия
	Заменяем на правую
	A -> $\beta 1$A'   | $\beta 3$A'  | $\beta 2$A'  | ... | $\beta k$A' 
	A' -> $\alpha 1$A'   | $\alpha 2$A' | $\alpha 3$A' | ... | $\alpha n$A' | Eps
2) Объединение общих начал. 
	было:
	A -> a$\alpha 1$ | a$\alpha 2$ | a$\alpha 2$ | ... | a$\alpha n$ | $\beta1$ | ... | $\beta k$ 
	first($\beta$) != {a}
	стало:
	A -> aA' | $\beta1$ | ... | $\beta k$ 
	A' -> $\alpha 1$ | $\alpha 2$ | $\alpha 2$ | ... | $\alpha n$
3) Терминализация 
	Было:
	A -> B1$\alpha 1$ | B2$\alpha 2$ | B3$\alpha 3$ | ... | Bn$\alpha n$ | $\beta1$ | ... | $\beta k$ 
	B1 -> $\gamma 11$ | $\gamma 12$ | ... | $\gamma 1m1$
	B2 -> $\gamma 21$ | $\gamma 22$ | ... | $\gamma 2m2$
	......
	Bn -> $\gamma n1$ | $\gamma n2$ | ... | $\gamma nmn$ 
	Действие: вместо каждого Bi подставляются все его альтернативы
4) Обработка Eps альтернативы 
	Было:
	A -> $\alpha 1$A | $\alpha 2$A | ... | $\alpha n$A |  $\beta1$ | ... | $\beta k$ | Eps
	B -> $\gamma$A$\delta$
	Пусть first(A) пересекается с follow(A)
	B -> $\gamma$A'
	A' -> $\alpha 1$A' | $\alpha 2$A' | ... | $\alpha n$A' |  $\beta1$$\delta$  | ... | $\beta k$$\delta$| $\delta$ 

### Реализация E альтернатив в функция рекурсивного спуска.
1) Если нетерминал схлопывающейся в Eps, то функция не кидает исключений на этот случий.
	Пример:
	A -> abB | E


## § 8.  Ухищрения для грамматик Я. П. : Построение грамматики модельного Я. П.
1) Подглядывание - запрос еще 1 лексемы
2) Итерация
	L -> a | a,L => L-> a{,a} {} = потвторение одного или более раз
	a - содержательный элемент
	, - разделитель
	void L() {
		if (lex != 'a') throw lex;
		while (get_lex, lex == ',') {
			get_lex();
			if (lex != 'a') throw lex;
		}
		return;
	}
	Условие применимости ухищирение:
	follow(L) не содержит разделитель
	
	Где итерации?
	1) Описание переменных 
	2) Аргументы функций
	3) выражения

### Грамматика выражений в Я. П.
Принцип: Каждый приоритет - нетерминал. 
Пример игрушечной грамматики.
	E -> E1 | E1 \[=| >|<] E1
	E1 -> T {\[+|-] T}
	T -> F{\[ \* | \/ ] F} 
	F -> I | N | (E)
Приоритеты пишутся от низким к высоким
На самом высококом приоритете есть (E)
Рекомендации по именованию 
\<exp15> ::= \<exp14>{\<op15>\<exp14>}
......
\<exp0> ::= \<Ident>|\<Literal>|\<exp>
